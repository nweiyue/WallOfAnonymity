let iosocket = io.connect(); //using io. object (which is defined in the socket library), 
//this is available to us because in index.html, we loaded socket libary in line 8
// we are calling the connect() method on the object, which will request a connection to the server that loaded our webpage
// with that connection, we store it in iosocket, which has a bunch of other methods 
// such as .on() which is almost exactly like an event listener: what it does is: 
// it takes the connect event generated by the system IF our connection request was successful 
//  and runs the function which does nothing but print a console message right now

let chatBox = document.getElementById("chatBox");
let typingBox = document.getElementById("typingBox");
let sendButton = 

// Open prompt box to prompt for the user name and assign this username you get from the user in that prompt box to a variable
let uname= prompt("Please enter your name");
uname = uname || "anon"; //in case the user does not input anything

iosocket.on('connect', function () {

    // MESSAGE PROCESSING HERE --------------
    // this is where we will process any message that comes from the server, 
    //including those that are sent to us from other clients through the server -----------------
    // to receive messages, we will use the socket connection to listen for message event
    // when the message event is generated, the callback function is called with an argument, m: the message that was sent
    iosocket.on('message', function(m) {
        //console.log("You received a message " + m.data); 
        //instead of just printing the object we get, we can print out the attribute we created to hold the message
        if (m.mtype === "chatText"){
            chatBox.value += m.username + ">" + m.data + "\n";
        } else {console.log("Your message type is not a text!")};
        // print the message out to the chatbox of other clients connected

        if(m.mtype === "drawingPath"){
            receiverPath = paper.path(m.data).attr({"stroke-width": m.strokeWidth, "stroke": m.strokeCol});
        } else {console.log("Your message is not a drawing")};
        


    });

    //---------------------------------------
    // if the connection was unsuccessful, we will define another event listener 'disconnect', 
    // so that if the server wants to disconnect it, it will respond to that and give ourselves another console message
    iosocket.on('disconnect', function() {
        console.log("Disconnected")
    });
});

 
// When the user is typing and hits 'return', add the 
//     message to the chat window and send the text to the server (and thus to others)
// the textarea elements take events and listen for events called 'keypress', everytime the keypress is pressed, 
// we will get an event callback 
typingBox.addEventListener('keypress', function(event){
    // when the operating systems calls the callback function, it returns us an object; 
    //this object is going to contain the key that was pressed
    // where does it contain the info about the key that was pressed? 
    //Ans: the keypress event has an attribute '.which' that is a number that indicates which key was pressed (every key has a different number)
    // the return key has the number '13', therefore we check for the return keypress and execute some code
	var mymessage; // holds text from the typingBox
	if(event.which == 13) {  // 'return' key
		event.preventDefault();

        //-----------get text, construct message object and send ------------------------------
        mymessage = typingBox.value;
        // write this text in the typingBox in the chatbox
        chatBox.value += uname + ">" + mymessage + "\n"; 
        //add new message to what was in the chatbox alr therefore +=  
        // and also add a line break to the message at the end, everytime i print the message to the chatbox
        // im going to print a new line
        typingBox.value ="";
        //clear the typingBox after we grab the message from typingBox to chatBox
        //-------------------------------------------------------------
        // we send the message to the server from where we grab it 
        iosocket.send({"username" : uname, "data": mymessage, "mtype": "chatText"});


	}
});


// //---------------------------------------------
// // Drawing chat 
// //---------------------------------------------

// //Step 5:
// // let colorString;
// //Step 6
// svgdiv.addEventListener("mousedown", function(ev){
    
//     //Step 14:
//     let colorString;
//     console.log(hue.value);
//     colorString = "hsl(" + hue.value + "," + sat.value + "," + light.value + ")"; 
//     pathString = `M ${ev.offsetX},${ev.offsetY} `;
//     raphaelPath = paper.path(pathString).attr({"stroke-width": strokeWidth.value, "stroke": colorString});
//     mousePushed = true;
// });

// //Step 7
// svgdiv.addEventListener("mousemove", function(ev){
//     if (mousePushed === true){
//         pathString += `L ${ev.offsetX},${ev.offsetY} `;
//         raphaelPath.attr({"path": pathString});
//     };
// });

// //Step 8
// svgdiv.addEventListener("mouseup", function(ev){
//     //Step 15:
//     let colorString;
//     // console.log(colorString);
//     colorString = "hsl(" + hue.value + "," + sat.value + "," + light.value + ")";
//     pathString += `L ${ev.offsetX},${ev.offsetY} `;
//     raphaelPath.attr({"path": pathString});
//     mousePushed = false;

//     //step 9
//     iosocket.send({"data": pathString, "mtype": "drawingPath", "strokeCol": colorString, "strokeWidth": strokeWidth.value});
// });



